# 微服务架构入门篇

## 一. 引言

> 通常来说，我们认为软件架构的发展经历了从单体结构->SOA架构->微服务架构的过程，这里我们分析这三种架它们的特点以及优缺点分析。
>

1. 单体架构及其优劣
2. SOA架构及其优劣
3. 什么是微服务
4. 什么是微服务架构及其优劣
6. 单体架构与微服务架构的对比

## 二.单体架构

### 2.1 什么是单体架构

简单来说，一个war/jar包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之为单体应用架构，这是一种比较传统的架构风格。

特点：

1、所有的功能集成在一个项目工程中。

2、所有的功能打一个war包部署到服务器。

3、应用与数据库分开部署。

4、通过部署应用集群和数据库集群来提高系统的性能。

![单体架构图片](images\单体架构图片.png)

### 2.2 单体架构优缺点

在程序规模不大，开发人员很少的时候，单体架构优点显著。

优点：

- 开发简单。单体应用的结构，天然决定了所有代码都集中在一起，开发者不需要在多个应用之间来回跳转来寻找其中的调用逻辑。
- 测试简单。所有代码都在一个应用里，测试人员可以很方便的做到端到端的测试。
- 部署简单。因为一个应用就是产品功能的全集，所以在部署的时候，只需要不是一款应用即可。即使是集群部署，也不会增加多少复杂度：只需要将应用部署多份即可。
- 开发迅速。上面的各种简单，带来的就是软件功能可以快速实现。很多时候，实现需求的速度是项目成功与否的决定性因素。

随着功能的持续增加、团队规模的不断扩大，我们很快就会发现单体应用的弊端：

- 应用膨胀。所有代码都在一个应用里，导致应用的代码量迅速上升，对于开发者来说，经常需要在海量的代码里找到自己需要维护的哪一行，这种体验往往是令人崩溃的。同时，对于IDE来说，一个应用内大量代码也会严重拖慢其运行效率。
- 团队合作冲突。这种冲突会体现在多个方面：开发阶段，很容易由于修改相同的代码导致代码冲突。部署阶段，又会因为“运行环境里跑的是谁的分支”而造成新的冲突。所有的这些冲突将会严重影响到团队的合作效率。
- 运行效率、稳定性。单体应用，由于逻辑都集中在一起，启动时需要完成所有的初始化工作；同时单一功能的问题也会因为运行在一个进程内，从而导致整个应用宕机。

## 三.SOA架构

SOA 是 Service-Oriented Architecture 的简写，直译为“面向服务的架构”，从命名上就可以看出“服务”是 SOA 架构里是非常重要的概念。SOA 的核心思想是“将系统的功能解构为一系列服务”。

> 面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。

![SOA架构](images\SOA架构.png)

SOA通过下面技术方案来解决

- XML - 一种标记语言，用于以文档格式描述消息中的数据。
- SOAP（Simple Object Access Protocol） - 在计算机网络上交换基于XML的消息的协议，通常是用HTTP。
- WSDL（Web Services Description Language，Web服务描述语言） - 基于XML的描述语言，用于描述与服务交互所需的服务的公共接口，协议绑定，消息格式。
- UDDI（Universal Description, Discovery, and Integration，是统一描述、发现和集成） - 基于XML的注册协议，用于发布WSDL并允许第三方发现这些服务。
- ESB（Enterprise Service Bus, 企业服务总线）- 支持异构环境中的服务、消息，以及基于事件的交互，并且具有适当的服务级别和可管理性。

特点：

1、基于SOA的架构思想将重复公用的功能抽取为**组件**，以服务的方式给各各系统提供服务。

2、各各项目（系统）与服务之间采用webservice、rpc等方式进行通信。

3、ESB企业服务总线作为项目与服务之间通信的桥梁。

优点：

1、将重复的功能抽取为服务，提高开发效率，提高系统的可重用性、可维护性。

2、可以针对不同服务的特点制定集群及优化方案。

3、采用ESB减少系统中的接口耦合。

缺点：

1、系统与服务的界限模糊，不利于开发及维护。

2、虽然使用了ESB，但是服务的接口协议不固定，种类繁多，不利于系统维护。

3、抽取的服务的粒度过大，系统与服务之间耦合性高。

4、中心化。虽然应用本身实现了分布式与水平扩展，但是 ESB 却成了系统的中枢神经。

5、不适应云环境。在如今的互联网时代，速度就是一切。由此诞生了敏捷开发、持续集成等在不同节点提升业务上线速度的办法。但是方向是不一致的。

6、高门槛。ESB 本身就是一套非常复杂的系统，通过 ESB 落地 SOA ，对开发人员的要求很高。甚至还会需要厂商参与。

## 四.微服务架构

### 4.1 什么是微服务

关于什么是微服务，2014年，Martin Fowler与James Lewis共同提出了微服务的概念， 有如下的定义：

> The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.?
>
> 微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。

从上面可以提到几个重要的概念：

- 一套小服务
- 独立进程
- 轻量级通信协议
- 可独立部署
- 多语言&不同储技术

简单来讲，微服务是一种用于构建应用的架构方案，**微服务的核心**就是将传统的单体架构拆分成单个服务，将业务间进行解耦，每个服务可以单独部署. 可以拥有自己的数据库这样拆分出来的服务就叫做微服务。就比如说，单体架构中有订单. 支付. 物流. 积分等业务，拆分成微服务，订单服务，支付服务，物流服务，积分服务等。

![微服务架构示意](images\微服务架构示意.png)

**微服务架构特点**

1. 由完成特定功能的小型服务组成

把一个庞大的系统拆分成多个模块，每个模块又可以细分多个微服务，每个服务都可独立的并且支持多节点部署，运行在独立的进程中。

2. 去中心化的服务治理

每个微服务允许使用不同的技术来开发， 且数据可以不再单独的保存在一个数据库中，允许多种数据库技术。

3. 高内聚低耦合的设计

组成各个应用的微服务，都要尽可能地实现“高内聚和低耦合”的目标，每个微服务都拥有自己的领域边界和完整的业务逻辑。

4. 容错设计和弹性设计

当服务发生故障时，能够快速地试错，能够快速地检测出故障，而且能够在一定的情况下自动恢复。

5. 自动化运维

基础设施例如服务器、数据库、中间件等能够弹性且自动化分配资源，微服务迭代构建要能够满足自动化的提交版本、自动化代码检查、自动化测试、自动化部署以及监控等。

### 4.2 微服务架构的优势

微服务相对于单体服务都有哪些优势。

#### 1. 敏捷开发
一个小的团队，甚至一个人，负责一个或者多个服务，当有新的需求出现，可以快速对这个小型服务做出修改并上线。但是当维护一个庞大的代码仓库构成的单体服务时，即使是一个简单的需求、只修改了一行代码，开发人员也会因为这行代码可能会影响整个应用，而降低部署的频率，从而累计多次代码提交再产生一次新的部署。

而我们知道两个版本的代码变动越多，产生问题的可能性就越大，甚至造成更严重的线上问题。相比之下，微服务可以让服务更敏捷地开发上线，这符合现在互联网业务快速迭代的特征。

#### 2. 技术自由
微服务团队，可以选择自己喜欢的技术或者语言，并不需要局限在同一种语言上。当出现了一种新的语言更适合解决现在的问题，团队可以快速做出反应，用新的语言编写新的服务或者改写旧的服务，不必考虑采用新语言带来的不确定性和成本问题。

#### 3. 弹性扩缩容
微服务可以灵活地应对服务的扩缩容问题。在单体服务中，假设某个接口在高峰期有较大的访问量，需要比平时增加一些机器应对，但我们很难根据 CPU 的水位做出准确的判断，因为所有接口都在一个应用中，而在微服务中做出这种判断要容易得多。

#### 4. 可重复使用的代码

将软件划分为小型且明确定义的模块，让团队可以将功能用于多种目的。专为某项功能编写的服务可以用作另一项功能的构建块。这样应用程序就可以自行引导，因为开发人员可以创建新功能，而无需从头开始编写代码。

### 4.3 微服务架构的问题

微服务并不是一劳永逸的解决了所有的问题，相反的，如果不能正确的使用微服务，则有可能被微服务自身的限制拖入另一个泥潭：

#### 1. **运维要求较高**
更多的服务意味着更多的运维投入，在单体架构中，只需要保证一个应用的正常运行，而在微服务中，需要保证几十甚至几百个服务正常运行与协作，这给运维带来了很大的挑战。
#### 2. **分布式固有的复杂性**
使用微服务构建的是分布式系统，对于一个分布式系统，系统容错，网络延迟等都会带来巨大的挑战。

原本在单体应用中，很多简单的问题都会在分布式环境下被几何级的放大。例如分布式事务、分布式锁、远程调用等，不光要考虑如何实现他们，相关场景的异常处理也是必须要考虑到的问题。

#### 3. **接口调整成本高**，协同代价高
微服务之间通过接口进行通信，如果修改某一微服务API，所有使用该接口的微服务都需要调整。

假设一个项目上线需要发布十几个应用，而这些应用又分别由多个团队在维护。你就能深刻的体会到协同是一件多么痛苦的事情了。

#### 4. **问题定位时间成本增加**
多个服务之间来回调用，问题定位变得更加复杂。

#### 5. 服务拆分错误

微服务的各种优势，其中一个重要的基础是对服务领域的正确切分。如果使用了不合适的切分粒度，或者是错误的切分方法，都会让服务不能很好的实现高内聚低耦合的要求。

### 4.4 **单体架构与微服务架构对比**

| 因    素               | 单体架构 | 微服务架构 | 说    明                                                     |
| ---------------------- | -------- | ---------- | ------------------------------------------------------------ |
| 交付速度               | 较慢     | 较快       | 服务拆分后，各个服务可以独立并行开发、测试、部署，交付效率提升，产品的更新速度会更快，用户体验更好。代码规模越大，微服务的优势越明显 |
| 故障隔离范围           | 线程级   | 进程级     | 服务独立运行，通过进程的方式隔离，使故障范围得到有效控制、架构变得更简单可靠。根据业务的重要程度划分服务，把核心的业务划分为独立的服务，这样从数据库到服务可以保持有效的故障隔离，进而保持稳定 |
| 整体可用性             | 较低     | 更高       | 微服务架构由于故障范围得到有效隔离，整体可用性更高，降低一点故障对整体的影响 |
| 架构持续演进           | 困难     | 简单       | 由于微服务的粒度更小，架构演进的影响面就更小。不存在大规模重构导致的各种问题。微服务架构对架构演进更友好 |
| 沟通效率               | 低       | 高         | 业界普遍认为团队规模越大，沟通效率越低，微服务架构按业务构建全功能团队，把权力下放，不会出现决策瓶颈点，缩小了沟通规模，提高了沟通效率 |
| 技术栈选择             | 受限     | 灵活       | 如果某个业务需要独立的技术栈，可以通过服务划分、接口集成的方式实现。例如搜索的技术栈、专业细分领域都不相同，通常采用独立的服务实现 |
| 可扩展性               | 受限     | 灵活       | 微服务架构可以根据服务对资源的要求以服务为粒度扩展，符合AKF扩展立方体中的Y轴扩展，而单体架构只能整体扩展，只能做到AKF扩展立方体中的X轴扩展 |
| 可重用性               | 低       | 高         | 微服务架构可以实现以服务为粒度通过接口共享重用               |
| 实现业务复杂性分解难度 | 困难     | 容易       | 微服务架构通过将业务分解为更多的服务，业务边界更清晰，更容易把一个复杂的问题分解为简单的小问题 |
| 产品创新复杂度         | 困难     | 容易       | 微服务架构以服务为粒度独立演进，团队有更多的自主决策权，更多的试错机会，更利于创新 |
| 一致性实现成本         | 低       | 高         | 服务划分后，如果服务A同时调用服务B和服务C，如何保证同时成功或失败？单体架构下的单库事务变成了分布式事务问题 |
| 时延                   | 低       | 高         | 服务划分后，调用次数增加，导致响应时间增加、吞吐量降低，如何弥补 |
| 资源成本               | 低       | 高         | 吞吐量的下降意味着要增加更多的资源，对于交付型项目，特别是小规模部署的场景下，是比较致命的 |
| 关联查询复杂度         | 简单     | 复杂       | 微服务架构的一个非常明显的特征就是，一个服务所拥有的数据只能通过这个服务的API来访问。通过这种方式来解耦，往往会带来查询问题。以前通过join就可以满足要求，现在如果需要跨多个服务集成查询，就会非常麻烦 |
| 远程调用               | 不涉及   | 涉及       | 微服务存在更多的远程调用，需要额外考虑序列化、通信协议、数据压缩、服务间的负载均衡、容错等问题 |
| 服务治理               | 不涉及   | 涉及       | 由于服务数量变多，微服务架构需要额外考虑服务的注册发现、依赖关系、治理等问题 |
| 对开发人员的要求       | 低       | 高         | 微服务架构更复杂，开发人员端到端负责，既要考虑接口定义，又要考虑数据库设计，对开发人员的水平要求更高 |
| 对工具的依赖           | 较低     | 较高       | 微服务架构中服务的数量较多，使用工具的效果更明显，依赖程度更高 |
| 运维复杂度             | 低       | 高         | 微服务架构中服务的数量较多，对服务的监控、健康检查要求更高，整体运维复杂度更高 |

### 4.5 微服务设计原则

#### 业务原则

- 单一责任原则：对于一个微服务而言，具有有限的业务范围，可以帮助我们满足服务开发和交付的敏捷性；
- 适当的边界：关注微服务的范围，而不是一味的把服务做小。一个服务的大小应该等于满足某个特定业务能力所需要的大小；
- 业务分层： 先把业务分层，形成单向依赖，避免微服务之间的网状依赖关系；
- 颗粒度递增：初期先把业务划分到尽可能细，然后依据其它原则合并到适当颗粒度；
- 非唯一依赖：至少被2个以上其它微服务依赖，才有必要独立成一个微服务。

#### 技术原则

- 部署独立性：能独立于其它微服务部署，一个微服务故障不影响其它微服务；
- 动态扩展：每个微服务都可以动态的进行x轴和z轴的扩展，并适应云环境下的自动化部署；
- 领域和应用分层： 提供数据基本操作能力的领域服务层和执行业务逻辑的应用服务层解耦；
- 避免产生频繁的跨库查询；
- 避免产生频繁的分布式事务。

#### 治理原则

- 根据业务和技术分层的情况，对微服务分组治理；
- 各个分组之间通过API网关集成；
- 通过API网关实现级轻量级消息路由，鉴权；
- 运行时管理，如性能，限流，监控等可在API网关实现，让微服务功能纯粹；
- 避免通过数据库集成；
- 避免部署多个版本来兼容。

## 五.Service Mesh （服务网格）

与其他现存的架构和解决方案一样，微服务架构也不是银弹，尽管它解决了单体服务的很多问题，却也带来了负载均衡、服务治理、服务注册发现、如何拆分服务等问题。

Service Mesh （服务网格）是一个用于处理服务和服务之间通信的基础设施层，它最重要的变革，就是引入了数据面和控制面的概念：通过 sidecar 模式将原本在 SDK 中的代码独立出来，用控制面代替配置中心的部分功能，以透明代理的形式提供安全、快速、可靠的服务间通信，同时也能实现微服务所需的基本组件功能。

 Service Mesh主要提供以下功能：

- 流量控制：流控是最主要也是最重要的功能，通过 Service Mesh，我们可以为应用提供智能路由（蓝绿部署、金丝雀发布、A/B test）、超时重试、熔断、故障注入、流量镜像等各种控制能力；
- 安全：在安全层面上，授权和身份认证也可以托管给 Service Mesh；
- 策略：可以为流量设置配额、黑白名单等策略；
- 可观察性：服务的可观察性一般是通过指标数据、日志、追踪三个方式展现的，目前的 Service Mesh 产品可以很容易和和主流的后端设施整合，提供给应用系统完整的监控能力。

