#  Netty学习(一)-理解BIO与NIO、AIO

一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO

## 1、同步和异步

- 同步：执行一个操作之后，等待结果，然后才继续执行后续的操作。
- 异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。
- 同步和异步的区别：数据拷贝阶段是否需要完全由操作系统处理。

##  2、阻塞和非阻塞

- 阻塞和非阻塞操作：是针对发起 IO 请求操作后，是否有立刻返回一个标志信息而不让请求线程等待。
- 阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。
- 非阻塞：进程给CPU传达任我后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。

来个例子理解一下概念，以银行取款为例： 

- 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）；
- 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）；
- 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；
- 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）

##  3、BIO与NIO、AIO

1、解释

- Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
- Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
- Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

2、功能和特性比较

| 类型 |  BIO(同步阻塞I/O)    |  NIO(同步非阻塞I/O)    | AIO(异步非阻塞I/O)     |      |
| ---- | ---- | ---- | ---- | ---- |
|  客户端个数：I/O线程    |   1：1   |  M:1(1个I/0线程处理多个客户端数)    |   M:0(不需要额外启动I/O线程，被动回调)   |      |
|    I/O类型（阻塞）  | 同步阻塞     |  同步非阻塞    |   异步非阻塞   |      |
|  API使用难度    |   简单   |   非常复杂   |   复杂    |     |
|  可靠性    |  非常差    |   高   |    高  |      |
| 吞吐量     |  低    |   中   |  高    |      |

3、NIO 和 BIO 的区别主要体现在三个方面

| **BIO**  | **NIO**      |
| ---------------- | ---- |
|  基于流( Stream )       |  基于缓冲区( Buffer )    |
| 阻塞 IO | 非阻塞 IO     |
| 选择器( Selector ) |  无    |

